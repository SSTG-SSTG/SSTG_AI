<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSTG AI Assistant with Memory</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar styling for the chat container */
        #response-container {
            max-height: 70vh; 
            overflow-y: auto;
            scroll-behavior: smooth;
            padding: 1.5rem;
        }

        /* Styling for the loading spinner animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }

        .dot-flashing {
            display: flex;
            align-items: center;
        }

        .dot-flashing > div {
            width: 8px;
            height: 8px;
            margin: 0 4px;
            background-color: #4f46e5; /* Indigo-600 */
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        .dot-flashing > div:nth-child(2) { animation-delay: 0.2s; }
        .dot-flashing > div:nth-child(3) { animation-delay: 0.4s; }

        /* Styling for citations */
        .citation {
            display: inline-flex;
            align-items: center;
            background-color: #eff6ff; /* Blue-50 */
            color: #3b82f6; /* Blue-500 */
            font-size: 0.75rem; /* text-xs */
            padding: 0.125rem 0.5rem;
            margin-left: 0.5rem;
            border-radius: 9999px; /* rounded-full */
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        .citation:hover {
            background-color: #dbeafe; /* Blue-100 */
        }

        /* Specific message styling for a chat bubble look */
        .ai-message {
            background-color: #ffffff;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1); /* Subtle shadow */
            border: 1px solid #e5e7eb;
        }

        .user-message {
            text-align: right;
            background-color: #e0f2fe; /* Light Blue for user message */
            border: 1px solid #bae6fd;
            margin-left: auto;
        }
    </style>
    <script>
        // --- MANDATORY CANVAS/GEMINI API SETUP ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        const apiKey = "AIzaSyC2XBVvc-DyRAaMqYYbeLOy_LUP4LS877E";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
        const MAX_RETRIES = 5;

        /**
         * The core variable for the memory function.
         */
        let chatHistory = []; 

        // Utility function for exponential backoff
        async function fetchWithRetry(url, options, retries = 0) {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    if (response.status === 429 && retries < MAX_RETRIES) {
                        const delay = Math.pow(2, retries) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        return fetchWithRetry(url, options, retries + 1);
                    }
                    throw new Error(`API call failed with status: ${response.status}`);
                }
                return response;
            } catch (error) {
                if (retries < MAX_RETRIES) {
                    const delay = Math.pow(2, retries) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return fetchWithRetry(url, options, retries + 1);
                }
                throw new Error(`Max retries reached. Final error: ${error.message}`);
            }
        }

        /**
         * Cleans and sanitizes the generated text for safe HTML display.
         */
        function cleanText(text) {
            if (!text) return '';
            return text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;")
                .replace(/\n/g, '<br>');
        }

        /**
         * Creates a chat bubble element for the user or AI.
         */
        function createMessageBubble(role, content) {
            const wrapper = document.createElement('div');
            wrapper.className = `flex mb-4 ${role === 'user' ? 'justify-end' : 'justify-start'}`;

            const bubble = document.createElement('div');
            bubble.className = `p-4 max-w-full md:max-w-xl rounded-2xl break-words ${role}-message ${role === 'user' ? 'rounded-br-sm' : 'rounded-tl-sm ai-message'}`;
            bubble.innerHTML = content;
            
            wrapper.appendChild(bubble);
            return wrapper;
        }
        
        /**
         * Renders the most recent AI response and citations to the UI.
         */
        function renderAIResponse(result) {
            const container = document.getElementById('response-container');
            const candidate = result.candidates?.[0];
            let contentHTML = "";
            let sources = [];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const text = cleanText(candidate.content.parts[0].text);
                contentHTML += `<p class="text-gray-700">${text}</p>`;

                // Extract grounding sources
                const groundingMetadata = candidate.groundingMetadata;
                if (groundingMetadata && groundingMetadata.groundingAttributions) {
                    sources = groundingMetadata.groundingAttributions
                        .map(attribution => ({
                            uri: attribution.web?.uri,
                            title: attribution.web?.title,
                        }))
                        .filter(source => source.uri && source.title);
                }
            } else {
                contentHTML = `<p class="text-red-500">I encountered an unexpected issue while generating a response. History has been maintained, but please try the query again.</p>`;
            }

            // Create the sources container if sources exist
            if (sources.length > 0) {
                const uniqueSources = new Map();
                sources.forEach(source => uniqueSources.set(source.uri, source));

                contentHTML += `<div class="mt-4 pt-4 border-t border-gray-100 flex flex-wrap justify-end space-x-2">`;
                
                uniqueSources.forEach(source => {
                    contentHTML += `<a href="${source.uri}" target="_blank" class="citation" title="${source.title}">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-3 h-3 mr-1">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25" />
                        </svg>
                        ${source.title.substring(0, 30)}${source.title.length > 30 ? '...' : ''}
                    </a>`;
                });
                contentHTML += `</div>`;
            }

            const aiBubble = createMessageBubble('ai', contentHTML);
            container.appendChild(aiBubble);
            container.scrollTop = container.scrollHeight;
        }

        /**
         * Main function to call the Gemini API, maintaining chat history/memory.
         */
        async function generateAIResponse(userQuery) {
            const sendButton = document.getElementById('send-button');
            const loadingIndicator = document.getElementById('loading-indicator');
            const inputField = document.getElementById('user-input');
            const responseContainer = document.getElementById('response-container');

            // 1. Prepare and Render User Message
            const userMessagePart = { role: "user", parts: [{ text: userQuery }] };
            chatHistory.push(userMessagePart); // Add user message to history state

            const userBubble = createMessageBubble('user', cleanText(userQuery));
            responseContainer.appendChild(userBubble);
            responseContainer.scrollTop = responseContainer.scrollHeight;

            // 2. Show Loading State and Disable Input
            sendButton.disabled = true;
            loadingIndicator.classList.remove('hidden');
            inputField.disabled = true;
            inputField.value = ''; // Clear input immediately after sending

            const payload = {
                // IMPORTANT: Send the entire chat history for memory
                contents: chatHistory, 
                // Enable Google Search grounding
                tools: [{ "google_search": {} }],
                systemInstruction: {
                    parts: [{ text: "You are the SSTG AI, a professional, highly informative, and succinct AI assistant. Maintain context from previous turns. Provide a high-quality, direct answer to the user's query. Format the output professionally." }]
                },
            };

            const options = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            try {
                // 3. Make the API call with retry logic
                const response = await fetchWithRetry(apiUrl, options);
                const result = await response.json();

                // 4. Update chat history with AI response
                const modelResponsePart = result.candidates?.[0]?.content;
                if (modelResponsePart) {
                    chatHistory.push(modelResponsePart); 
                }

                // 5. Render the response
                renderAIResponse(result);

            } catch (error) {
                console.error("Error during API generation:", error);
                const errorHtml = `<p class="text-red-700 font-semibold">Connection Error:</p><p class="text-red-600 mt-1">We couldn't reach the AI service. Please check your network or try again shortly.</p>`;
                const errorBubble = createMessageBubble('ai', errorHtml);
                responseContainer.appendChild(errorBubble);

                // If API failed, remove the user's message from history to allow retry/re-prompt
                chatHistory.pop(); 
            } finally {
                // 6. Hide Loading State and Enable Input
                loadingIndicator.classList.add('hidden');
                sendButton.disabled = false;
                inputField.disabled = false;
                inputField.focus(); 
            }
        }

        // Event listener setup
        function setupEventListeners() {
            const sendButton = document.getElementById('send-button');
            const inputField = document.getElementById('user-input');

            sendButton.addEventListener('click', () => {
                const query = inputField.value.trim();
                if (query) {
                    generateAIResponse(query);
                }
            });

            // Allow sending by pressing Enter key
            inputField.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) { 
                    e.preventDefault();
                    if (inputField.value.trim()) {
                        sendButton.click();
                    }
                }
            });
        }

        window.onload = setupEventListeners;

    </script>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4 font-sans">

    <!-- UPDATED: max-w-6xl for wider view and h-[95vh] for more height -->
    <div class="w-full max-w-6xl bg-gray-50 shadow-2xl rounded-xl flex flex-col h-[95vh] md:h-[90vh] overflow-hidden">

        <!-- Header -->
        <header class="p-4 md:p-5 border-b border-indigo-200 bg-indigo-600">
            <h1 class="text-xl md:text-2xl font-bold text-white">SSTG AI</h1>
            <p class="text-indigo-200 text-sm">POWERD BY SSTG</p>
        </header>

        <!-- Response Area -->
        <main id="response-container" class="flex-grow space-y-4">
            <!-- Initial welcome message (AI style) -->
            <div class="flex justify-start">
                <div class="ai-message p-4 max-w-full md:max-w-xl rounded-2xl rounded-tl-sm">
                    <!-- UPDATED: Reference to SSTG AI -->
                    <p class="text-gray-700 font-medium">Welcome! I am the SSTG AI Assistant.</p>
                </div>
            </div>
            <!-- AI and User responses will be inserted here -->
        </main>

        <!-- Input Area -->
        <div class="p-4 md:p-6 border-t border-gray-200 bg-white">
            <div class="flex items-end space-x-3">
                <textarea
                    id="user-input"
                    class="flex-grow p-3 border border-gray-300 rounded-xl resize-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none transition-all duration-200 text-gray-800 placeholder-gray-500"
                    placeholder="Type your question here..."
                    rows="1"
                    aria-label="User input text area for chat"
                ></textarea>
                <button
                    id="send-button"
                    class="flex-shrink-0 bg-indigo-600 text-white w-12 h-12 rounded-xl flex items-center justify-center hover:bg-indigo-700 transition-colors duration-200 shadow-lg enabled:hover:shadow-xl disabled:bg-gray-400 disabled:shadow-none"
                    aria-label="Send message"
                    title="Send Message"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                        <line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                    </svg>
                </button>
            </div>
            <!-- Loading Indicator -->
            <div id="loading-indicator" class="hidden text-center mt-3">
                <div class="dot-flashing justify-center">
                    <div></div>
                    <div></div>
                    <div></div>
                </div>
            </div>
        </div>

    </div>
</body>
</html>

